\chapter{Introduction}

\todo[inline]{This chapter will probably be split in two.}


\section{The Size of a Cube}


\section{Historical Encounters}

%It has been recognized that parameters need not be restricted to one dimensional numerical values.
%Yet, to our knowledge the true limits of parameters have not been investigated before.

%TODO: Introduce algorithmic complexity as any complexity measure rooted in the length of procedures.
%TODO: Introduce Kolmogorov complexity (instance complexity is defined in Section~\ref{sec:algorithmic}).


\section{Measuring Convergence}
\todo[inline]{This section is not ready for critique.}

\todo[inline]{
  $\bbN \deq \{1, 2, 3, \ldots\}$, $\binary \deq \{\bits{1}, \bits{0}\}$,
  the finite nonempty binary strings $\binary^+$ are enumerated in order of increasing length as
  $\bits{0}, \bits{1}, \bits{00}, \bits{01}, \bits{10}, \bits{11}, \bits{000}, \ldots$
  leading to the commutative diagram
  $\bbN \text{rightleftarrows}^{\asStr}_{\asNat} \binary^+$. %tikz in equation
  Observe that for all $m, n \in \bbN$ we have $m \le n \implies \length{\asStr(m)} \le \length{\asStr(n)}$.
  %TODO: Pairing using the Cantor polynomial: $(a, b) \mapsto \frac{1}{2}((a + b)^2 -3a - b) + 1$
  %      The pairing for \bbN induces a pairing for \binary^+
  %NOTE: we do not have \length{\pair{a}{b}} = \length{a} + f(b) or vice versa
  %      alternatively, define a pairing such that \length{\pair{a}{b}} = max(\length{a}, \length{b}) + 2 min(\length{a}, \length{b}) + 1
  %TODO: All sets are countable, in particular when we speak of polynomials, all coefficients and powers are assumed to be in $\bbN$.
  %TODO: for a function f and constant c, c + f is the function x \mapsto c + f(x) and c · f is the function x \mapsto c · f(x).
  %TODO: Remark than we deviate from the \bigO convention of using functions as arguments in \cltime and use n as a free variable there.

  %References:
  %Logic: Kleene
  %Computability theory: Odifreddi, Rogers
  %Complexity theory: Goldreich, Arora&Barak
  %Algorithmic complexity theory: Li&Vitányi, Downey&Hirschfeldt
  %Order theory: Davey&Priestley, Abramsky&Jung
}

We take a 21st century approach to complexity theory, where we do not consider physical computers to be approximations of Turing machines, but Turing machines to be asymptotically correct mathematical models of physical computers.
Our machine model hence takes the form of `reasonable' pseudocode.
That is, a programming language that is more or less obviously Turing complete, yet not stronger than that.
%TODO: Check that we actually use pseudocode in this dissertation
%  --> We do, but maybe warn that for each statements can have else clauses!
%  --> Also, we use modern techniques like pattern matching: an input $\pair{x}{y}$ means that the input string is interpreted as a pair of strings
%TODO: Refer to the sequential computation thesis [emdeboas2014machine], also known as the extended Church--Turing thesis [parberry1986parallel].
%      We use that simulation is possible with polynomial overhead.

%TODO: move the following to somewhere sensible.
\begin{definition}
  The \defkey{rank} of a string $x$ relative to a set $X$, denoted by $\rank(x : A)$ is the number of elements in the set
  \begin{equation*}
    \{y \in X \st \asNat(y) \le \asNat(x)\}.
  \end{equation*}

  A set relative to which the function $\rank$ is computable in polynomial time is called \defkeyat{p-rankable@\slp-rankable}{\slp-rankable}.
\end{definition}
The \slp-rankable sets were originally known as \emph{strongly \cl{P}-rankable} \parencite{goldberg1991compression}.

A \emph{procedure} is the functional behavior of any particular Turing machine and can be represented by a pseudocode \emph{algorithm}.
We strife for a strongly, yet sometimes implicitly, typed treatment, with the exception that we freely use sets in place of their characteristic functions.
%TODO: Elaborate: thus, a decision procedure for A is any procedure \phi such that, for all $x$, we have \phi(x) = A(x).
%TODO: There is a length notion for procedures, but this depends on the chosen encoding, e.g., on the programming language.
%TODO: We limit ourselves to prefix-free encodings and our notion of Kolmogorov complexity will follow this choice.
%TODO: There is no universally best prefix-free encoding.
%      Fix a simple encoding that encodes an n-bit string as a n + 2\log n bit string.
%      This will work fine for our purposes.
\begin{definition}
  A \defkey{partial decision procedure} is a procedure that takes a string as input and produces an output in the set $\{\bits{1}, \bits{0}, \bits{?}\}$, representing the judgments `yes', `no', and `unknown'.
%TODO: use a different name or shy the concept altogether.

  Likewise, a \defkey{parameterized procedure} is a procedure that takes \emph{two} strings as input and produces an output in the set $\{\bits{1}, \bits{0}, \bits{?}\}$.
\end{definition}

We distinguish procedures from the functions they compute and shall use $\phi$ and $\psi$ for procedures, whereas we shall use $f$, $g$, and $h$ for functions. %TODO: verify
Note that, as a function, partial decision procedures and parameterized procedures are \emph{total}.
They are halting on every input.

\begin{definition}
  Given a function $t$, a partial decision procedure $\phi$ is a \defkeyat{approximation@$t$-approximation}{$t$-approximation} for a set $A$ if it satisfies, for every string $x$,
  \begin{itemize}
  \item $\phi$ terminates on input $x$ within $t(\length{x})$ steps, and
  \item if $\phi(x)$ is not \bits{?}, it is equal to $A(x)$.
  \end{itemize}
  The $t$-approximation is said to \emph{decide} the elements of its \emph{domain}
  \begin{equation*}
    \dom(\phi) \deq \{x \st \phi(x) \neq \bits{?}\}.
  \end{equation*}
\end{definition}
The \defkeyat{approximation@$t$-approximation!polynomial}{polynomial approximations} \parencite{ko1981completeness,balcazar1985bi-immune} are $t$-approximations where $t$ is a polynomial.
Likewise, a partial decision procedure is an \defkeyat{approximation@$t$-approximation!O(f)@$\bigO(f)$}{$\bigO(f)$-approximation} if it is a $t$-approximation for some $t \in \bigO(f)$.
For time-constructible functions $t$, the domain of a $t$-approximation is decidable in time $t$.
In particular, the domain of a polynomial approximation is in \cl{P}, without an increase in the exponent of the polynomial.
The domain of a polynomial approximation is also known as the \emph{definite part} of the approximation.

%convergence everywhere and uniquely
\begin{definition}
  A \defkey{quasiparameterization} is a directed cover of $\binary^+$, indexed by $\binary^+$.
  The elements of a quasiparameterization are called its \defkeyat{slice}{slices}.
\end{definition}
%Does it have a supremum? If so, it is a dcpo from domain theory!

Note that a quasiparameterization is necessarily countable, while there are uncountably many subsets of $\binary^+$.

%uniqueness of the limit set for a given parameterized procedure
%NOTE: With the point-cofinite requirement, the directedness is not really needed anymore, although point-cofinite nondirected covers are possible.
%      Requiring a parameterization to be directed mainly has a conceptual (axiomatic) reason.
\begin{definition}
  A \defkey{parameterization} is a point-cofinite quasiparameterization, meaning each $x \in \binary^+$ is excluded from only finitely many elements of the cover.
\end{definition}

\begin{example}
  A noteworthy example of a parameterization is the \defkey{length parameterization},
  \begin{equation*}
    (\{x \st \length{x} \le \asNat(k)\})_{k \in \binary^+}.
  \end{equation*}
  In this parameterization, depicted in Figure~\ref{fig:length_parameterization}, the parameter value $k$ acts as an upper bound to the lengths of instances.
  Given our previous discussion, however, it is better to think of the instances independent of their encoding.
  In that sense, the length parameterization is not philosophically pure.
  \begin{figure}
  %TODO: add a picture showing the length parameterization (x/k axes)
  \caption{
    An initial segment of the length parameterization.
    Note that the elements of the parameterization, depicted as rows in the figure, are finite.
    Furthermore, the inclusion order on the elements of the parameterization matches the natural enumeration order on the set $\binary^+$ of parameter values.
    Neither of these two properties is required to hold for an arbitrary parameterization.
  }
  \label{fig:length_parameterization}
  \end{figure}
\end{example}

Parameterizations are intended to measure structures other than the length of an instance.
We therefore prefer to use a symbol orthographically similar to $n$, which is commonly used to indicate a length, for parameterizations: $\eta$.
By convention from parameterized complexity theory, we use $k$ for indices in parameterizations, and call $k$ a \emph{parameter value}.
The $k$th slice of a parameterization $\eta$ is denoted by $\eta_k$.
For instances, we shall mostly use $x$.

In this framework, a parameterization $\eta$ associates to an instance $x$ the set of parameter values $\{k \st x \in \eta_k\}$.
Conversely, other frameworks have parameterizations associate specific parameter values to instances.
This is the case for the two dominant schools, that of \textcite{downey1999parameterized}, and that of \textcite{flum2006parameterized}.
Most often, the parameter value is interpreted as a single number, though it has been recognized that this is no necessity \parencite{fellows2013towards,niedermeier2010reflections}.

To facilitate a comparison between parameterizations \parencite{komusiewicz2012new}, we numerically capture the point of convergence for some input given a parameterization.
\begin{definition}
  Given a parameterization $\eta$, the \defkeyat{m@$\mu_\eta$}{minimization function} of $\eta$ is defined as
  \begin{equation*}
    \mu_\eta(x) = \min\{\length{k} \st x \in \eta_k\}.
  \end{equation*}
\end{definition}
Note that $\mu_\eta$ minimizes with respect to the length of parameter values and not with respect to the inclusion order on the parameterization.

Given a parameterized procedure $\phi$ we say that $\phi$ converges to a set $A$ if there is a parameterization $\eta$ such that for all $(x, k) \in \binary^+ \times \binary^+$ we have
\begin{equation*}
  x \in \eta_k \:\implies\: \phi(x, k) = A(x).
\end{equation*}
Such a set $A$ is uniquely determined by the parameterized procedure and depends only on the existence, not the specifics, of an appropriate parameterization.

Of particular importance are the parameterized procedures $\phi$ for which
\begin{equation*}
  (\{x \st \phi(x, k) \neq \bits{?}\})_{k \in \binary^+}
\end{equation*}
is a parameterization and, for some set $A$ and all $x$ and $k$, $\phi(x, k)$ is either \bits{?} or $A(x)$.
We call such parameterized procedures \defkeyat{parameterized procedure!direct}{direct}.
A parameterization $\eta$ corresponding to a direct parameterized procedure is decidable and the parameterized procedure doubles as a decision procedure for $\eta$.
The minimization function $\mu_\eta$ of such a parameterization is a measure of complexity insofar as it satisfies the axioms of \textcite{blum1967machine}.
Direct parameterized procedures have the epistemic interpretation that they know when they are right.
